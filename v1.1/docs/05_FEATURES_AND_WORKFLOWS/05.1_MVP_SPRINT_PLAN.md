# Week-by-Week Sprint Plan: Hybrid Approach to Dec 1 Launch

## Sprint Overview

- **Duration:** 4.5 weeks (30 days)
- **Team:** 2 developers (1 backend, 1 frontend)
- **Scope:** MVP with Phase 5 features (refunds + disputes)
- **Go-Live:** December 1, 2025
- **Deployment Target:** Vercel + Supabase

---

## Week 0: Pre-Sprint Prep (Days -2 to 0)

### Prerequisites

- [ ] Team locked in (2 full-time devs confirmed)
- [ ] Stripe Connect account verified
- [ ] MySQL data export ready
- [ ] GitHub repo created for new project
- [ ] Supabase + Vercel accounts provisioned

### Kickoff Meeting (2 hours)

- [ ] Review this sprint plan
- [ ] Define blockers & escalation process
- [ ] Set daily standup time (15 mins, 10am)
- [ ] Confirm go/no-go decision point (Day 5)

### Environment Setup (4 hours split)

- [ ] Backend dev: Clone repo, run `npm install`, test Supabase connection
- [ ] Frontend dev: Copy shadcn/ui components from current project, set up styling

---

## Week 1: Foundation (Days 1-5)

**Goal:** Infrastructure in place, MVP schema defined, first API route working

### Day 1: Supabase + Next.js Scaffold (Backend Lead)

**Morning (Dev env setup)**

- [ ] Create Supabase project in US-East region (faster performance)
- [ ] Get DB connection string, save to `.env.local`
- [ ] Install Supabase CLI: `npm install -g supabase`
- [ ] Verify connection: `supabase status`

**Afternoon (Next.js setup)**

- [ ] `npx create-next-app@latest suburbmates-v2 --typescript --tailwind`
- [ ] Add dependencies:
  ```bash
  npm install @supabase/supabase-js stripe zod react-hook-form next-auth
  npm install -D @types/node typescript
  ```
- [ ] Configure path aliases in `tsconfig.json`:
  ```json
  {
    "compilerOptions": {
      "baseUrl": ".",
      "paths": {
        "@/*": ["app/*"],
        "@/lib/*": ["lib/*"],
        "@/components/*": ["components/*"]
      }
    }
  }
  ```
- [ ] Create folder structure:
  ```
  app/
    api/
      auth/
      business/
      products/
      orders/
      refunds/
      disputes/
      webhooks/
    components/
      ui/
      layouts/
      forms/
  lib/
    db.ts (Supabase client)
    schemas.ts (Zod validation)
    stripe.ts
  public/
  ```
- [ ] Commit: `Initial Next.js + Supabase scaffold`

**Reference:** Current project structure from `package.json`

### Day 2: Database Schema - Phase 1 (Backend Lead)

**Morning: Core Tables (3 hours)**

Create Supabase migrations:

```sql
-- Run in Supabase SQL editor

-- 1. Users (mapped from Supabase auth)
CREATE TABLE profiles (
  id BIGINT PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT UNIQUE NOT NULL,
  name TEXT,
  role TEXT CHECK (role IN ('buyer', 'business_owner', 'vendor', 'admin')),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 2. Business Profiles (from current "businesses" table)
CREATE TABLE business_profiles (
  id BIGSERIAL PRIMARY KEY,
  owner_id BIGINT NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  suburb TEXT NOT NULL, -- Melbourne suburb name
  category TEXT,
  phone TEXT,
  website TEXT,
  verified_abn TEXT,
  profile_image_url TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(owner_id) -- One business per owner for MVP
);

-- 3. Vendors (from current "vendorsMeta" table)
CREATE TABLE vendors (
  id BIGSERIAL PRIMARY KEY,
  business_id BIGINT NOT NULL UNIQUE REFERENCES business_profiles(id) ON DELETE CASCADE,
  stripe_account_id TEXT UNIQUE,
  stripe_connect_id TEXT,
  subscription_status TEXT DEFAULT 'free' CHECK (subscription_status IN ('free', 'active', 'cancelled')),
  total_earnings_cents BIGINT DEFAULT 0,
  bank_account_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 4. Products (from current "products" table)
CREATE TABLE products (
  id BIGSERIAL PRIMARY KEY,
  vendor_id BIGINT NOT NULL REFERENCES vendors(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  price_cents BIGINT NOT NULL,
  category TEXT,
  kind TEXT DEFAULT 'service' CHECK (kind IN ('service', 'product', 'package')),
  fulfillment_method TEXT DEFAULT 'both' CHECK (fulfillment_method IN ('pickup', 'delivery', 'both')),
  stock_quantity INT DEFAULT 999,
  image_url TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  stripe_product_id TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for query optimization
CREATE INDEX idx_products_vendor_id ON products(vendor_id);
CREATE INDEX idx_products_is_active ON products(is_active);
```

**Afternoon: Transactions Tables (2 hours)**

```sql
-- 5. Orders (from current "orders" table)
CREATE TABLE orders (
  id BIGSERIAL PRIMARY KEY,
  buyer_id BIGINT NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  vendor_id BIGINT NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  product_id BIGINT NOT NULL REFERENCES products(id),
  quantity INT DEFAULT 1,
  total_cents BIGINT NOT NULL,
  payment_status TEXT DEFAULT 'pending' CHECK (payment_status IN ('pending', 'succeeded', 'failed')),
  fulfillment_status TEXT DEFAULT 'pending' CHECK (fulfillment_status IN ('pending', 'ready', 'completed', 'cancelled')),
  stripe_payment_intent_id TEXT UNIQUE,
  shipping_address JSONB,
  notes TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_orders_buyer_id ON orders(buyer_id);
CREATE INDEX idx_orders_vendor_id ON orders(vendor_id);
CREATE INDEX idx_orders_payment_status ON orders(payment_status);

-- 6. Refund Requests (from current "refundRequests" table)
CREATE TABLE refund_requests (
  id BIGSERIAL PRIMARY KEY,
  order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  buyer_id BIGINT NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  reason TEXT NOT NULL CHECK (reason IN ('not_as_described', 'changed_mind', 'defective', 'other')),
  description TEXT NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected', 'processing', 'completed')),
  refund_amount_cents BIGINT,
  stripe_refund_id TEXT,
  vendor_response TEXT,
  responded_at TIMESTAMP,
  processed_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_refund_requests_order_id ON refund_requests(order_id);
CREATE INDEX idx_refund_requests_buyer_id ON refund_requests(buyer_id);
CREATE INDEX idx_refund_requests_status ON refund_requests(status);

-- 7. Disputes (from current "disputeLogs" table)
CREATE TABLE disputes (
  id BIGSERIAL PRIMARY KEY,
  order_id BIGINT NOT NULL REFERENCES orders(id),
  buyer_id BIGINT NOT NULL REFERENCES profiles(id),
  vendor_id BIGINT NOT NULL REFERENCES profiles(id),
  refund_request_id BIGINT REFERENCES refund_requests(id),
  status TEXT DEFAULT 'open' CHECK (status IN ('open', 'under_review', 'resolved', 'escalated')),
  reason TEXT NOT NULL,
  buyer_evidence JSONB, -- Array of evidence URLs
  vendor_response TEXT,
  admin_decision TEXT,
  resolution_status TEXT CHECK (resolution_status IN ('buyer_refund', 'vendor_keeps', 'split')),
  decided_at TIMESTAMP,
  decided_by BIGINT REFERENCES profiles(id),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_disputes_order_id ON disputes(order_id);
CREATE INDEX idx_disputes_status ON disputes(status);
```

**Commit:** `feat: Core schema tables (profiles, products, orders, refunds, disputes)`

### Day 3: RLS Policies + Data Validation (Backend Lead)

**Morning: Supabase RLS Policies (2 hours)**

```sql
-- Enable RLS on all tables
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE business_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE vendors ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE refund_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE disputes ENABLE ROW LEVEL SECURITY;

-- Policy: Users can view their own profile
CREATE POLICY "Users can view their own profile" ON profiles
FOR SELECT USING (auth.uid() = id);

-- Policy: Users can view all public business profiles
CREATE POLICY "All users can view business profiles" ON business_profiles
FOR SELECT USING (TRUE);

-- Policy: Business owners can update their own profile
CREATE POLICY "Business owners can update own profile" ON business_profiles
FOR UPDATE USING (auth.uid() = owner_id);

-- Policy: Users can view products
CREATE POLICY "All can view active products" ON products
FOR SELECT USING (is_active = TRUE);

-- Policy: Vendors can manage their products
CREATE POLICY "Vendors can manage own products" ON products
FOR ALL USING (
  EXISTS (
    SELECT 1 FROM vendors v
    WHERE v.id = products.vendor_id
    AND v.business_id IN (
      SELECT id FROM business_profiles WHERE owner_id = auth.uid()
    )
  )
);

-- Policy: Users can view orders they're involved in
CREATE POLICY "Users can view own orders" ON orders
FOR SELECT USING (
  auth.uid() = buyer_id OR auth.uid() = vendor_id
);

-- Policy: Buyers can create refund requests for their orders
CREATE POLICY "Buyers can request refunds" ON refund_requests
FOR INSERT WITH CHECK (auth.uid() = buyer_id);

-- Policy: Users can view disputes they're involved in
CREATE POLICY "Users can view related disputes" ON disputes
FOR SELECT USING (
  auth.uid() = buyer_id OR auth.uid() = vendor_id
);

-- Policy: Admins can view/update disputes
CREATE POLICY "Admins can manage disputes" ON disputes
FOR ALL USING (
  EXISTS (
    SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'
  )
);
```

**Afternoon: Data Integrity Tests (2 hours)**

- [ ] Write Supabase SQL test suite to verify:
  - RLS policies work correctly
  - Foreign keys prevent orphaned data
  - Indexes created successfully
  - Test user can insert data with proper role

**Commit:** `feat: RLS policies + data integrity verification`

### Day 4: Database Client + Schemas (Backend Lead)

**Morning: Supabase Client (1 hour)**

Create `lib/db.ts`:

```typescript
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseKey);

// Server-side client with service role (for webhooks)
export const supabaseAdmin = createClient(
  supabaseUrl,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Helper functions for common queries
export async function getBusinessProfile(businessId: number) {
  const { data, error } = await supabase
    .from("business_profiles")
    .select("*")
    .eq("id", businessId)
    .single();

  if (error) throw error;
  return data;
}

export async function getVendorProducts(vendorId: number) {
  const { data, error } = await supabase
    .from("products")
    .select("*")
    .eq("vendor_id", vendorId)
    .eq("is_active", true);

  if (error) throw error;
  return data;
}

export async function createOrder(params: {
  buyerId: string;
  vendorId: number;
  productId: number;
  quantity: number;
  totalCents: number;
  stripePaymentIntentId: string;
}) {
  const { data, error } = await supabase
    .from("orders")
    .insert([
      {
        buyer_id: params.buyerId,
        vendor_id: params.vendorId,
        product_id: params.productId,
        quantity: params.quantity,
        total_cents: params.totalCents,
        stripe_payment_intent_id: params.stripePaymentIntentId,
        payment_status: "pending",
      },
    ])
    .select()
    .single();

  if (error) throw error;
  return data;
}
```

**Afternoon: Zod Schemas (2 hours)**

Create `lib/schemas.ts` (reuse from current project):

```typescript
import { z } from "zod";

// Reused from current tRPC routers
export const createBusinessSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().optional(),
  suburb: z.string().min(1),
  category: z.string().optional(),
  phone: z.string().optional(),
  website: z.string().url().optional(),
});

export const createProductSchema = z.object({
  title: z.string().min(1).max(255),
  description: z.string().optional(),
  price: z.number().positive(),
  category: z.string().optional(),
  kind: z.enum(["service", "product", "package"]).default("service"),
  fulfillmentMethod: z.enum(["pickup", "delivery", "both"]).default("both"),
  stockQuantity: z.number().int().default(999),
});

// Reused refund schema from current project
export const requestRefundSchema = z.object({
  orderId: z.number().positive(),
  reason: z.enum(["not_as_described", "changed_mind", "defective", "other"]),
  description: z.string().min(10).max(1000),
});

export const approveRefundSchema = z.object({
  refundId: z.number().positive(),
  vendorResponse: z.string().optional(),
  refundAmountCents: z.number().nonnegative().optional(),
});

// Reused dispute schema
export const openDisputeSchema = z.object({
  refundRequestId: z.number().positive(),
  reason: z.string().min(10),
  buyerEvidence: z.array(z.string().url()).optional(),
});
```

**Commit:** `feat: Supabase client + validation schemas`

### Day 5: First API Route + Go/No-Go (Backend Lead)

**Morning: Single Working Endpoint (3 hours)**

Create `app/api/business/route.ts`:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { supabase } from "@/lib/db";
import { createBusinessSchema } from "@/lib/schemas";

export async function GET(req: NextRequest) {
  try {
    const { data, error } = await supabase
      .from("business_profiles")
      .select("*")
      .eq("verified_abn IS NOT NULL", true) // Only verified businesses
      .limit(20);

    if (error) throw error;
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to fetch businesses" },
      { status: 500 }
    );
  }
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const parsed = createBusinessSchema.parse(body);

    // Get user from session
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user)
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

    // Create business profile
    const { data, error } = await supabase
      .from("business_profiles")
      .insert([
        {
          owner_id: user.id,
          name: parsed.name,
          description: parsed.description,
          suburb: parsed.suburb,
          category: parsed.category,
          phone: parsed.phone,
          website: parsed.website,
        },
      ])
      .select()
      .single();

    if (error) throw error;
    return NextResponse.json(data, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(error.errors, { status: 400 });
    }
    return NextResponse.json(
      { error: "Failed to create business" },
      { status: 500 }
    );
  }
}
```

Test locally:

```bash
npm run dev
curl http://localhost:3000/api/business
```

**Afternoon: GO/NO-GO Decision Point (2 hours)**

**Checkpoint Criteria:**

- [ ] Supabase project created + connection verified
- [ ] Schema tables created + data integrity tests pass
- [ ] First API route working end-to-end
- [ ] RLS policies validated
- [ ] Team confidence level

**Decisions:**

- ✅ **GO:** Proceed with full sprint
- ⚠️ **GO with caution:** One blocker found, proceed with adjusted timeline
- ❌ **NO-GO:** Major blocker → pivot to Option B (v1.1 MVP without Phase 5)

**Commit:** `test: First API route + go-live checkpoint`

**Daily Standup:** 15 mins, sync frontend progress

---

## Week 1 Summary (Frontend Parallel Work)

### Frontend Dev (Days 1-5) - Parallel to Backend

**Day 1-2: Components Setup**

- [ ] Copy `client/src/components/ui/*` from current project
- [ ] Install shadcn/ui: `npx shadcn-ui@latest init`
- [ ] Set up theme provider + global styles
- [ ] Create `components/layouts/MainLayout.tsx`

**Day 3-4: Page Structure**

- [ ] Create `/app/` directory structure for all routes
- [ ] Create placeholder pages for all MVP routes
- [ ] Set up Next.js Image + next/link components
- [ ] Create `hooks/useAuth.ts` hook (Supabase-based)

**Day 5: Review + Sync**

- [ ] Confirm pages ready for API integration
- [ ] Validate styling consistency
- [ ] Sync with backend on API contract

---

## Weeks 2-4 (Concurrent Development)

Given token constraints, I'll outline the remaining weeks at a high level with daily tasks you can expand:

### Week 2: Core Marketplace API

**Backend (Days 6-10):**

- [ ] Business CRUD: POST, GET, PUT business profile
- [ ] Product CRUD: Create, list, update, delete products
- [ ] Search API: List businesses by suburb/category
- [ ] Implement pagination (limit, offset)
- [ ] Add Stripe product creation on product POST

**Frontend (Days 6-10):**

- [ ] `/directory` page (business listing with search)
- [ ] `/business/[id]` page (detail view + product list)
- [ ] `/dashboard` page (user hub)
- [ ] Integrate API calls with TanStack Query (React Query)

### Week 3: Phase 5 (Refunds + Disputes)

**Backend (Days 11-15):**

- [ ] Refund request API: POST `/api/orders/[id]/refund`
- [ ] Refund approval: POST `/api/refunds/[id]/approve`
- [ ] Stripe refund webhook handler
- [ ] Dispute escalation: POST `/api/disputes/[id]/open`
- [ ] Admin dispute resolution: PUT `/api/disputes/[id]/resolve`

**Frontend (Days 11-15):**

- [ ] `/orders/[id]` page (order details)
- [ ] `/orders/[id]/refund` form (refund request)
- [ ] `/admin/disputes` dashboard
- [ ] Dispute resolution form (admin only)

### Week 4: AI Support + Testing + Deploy

**Backend (Days 16-17: Chatbot-Heavy Support)**

1. **FAQ Chatbot Setup (Claude RAG)**
   - [ ] Create FAQ index: `lib/support/faqs.ts` (indexed docs)
   - [ ] Add Claude integration: `app/api/support/chatbot/route.ts`
   - [ ] Implement RAG: fetch relevant FAQ docs for user query
   - [ ] Add rate limiting (Claude: ~$2/month budget)
   - [ ] Event emission: `support.chatbot.shown` / `resolved` / `escalated`

2. **Billing Auto-Response (Stripe Read-Only)**
   - [ ] Create: `app/api/support/billing/route.ts`
   - [ ] Stripe client in read-only mode: `STRIPE_API_KEY_RO` (restricted token)
   - [ ] Fetch recent invoices/charges by customer email
   - [ ] Response template: "Last charge: $X on [date]. Next steps: [link]"
   - [ ] **Guardrail:** Never initiate refunds; only read operations
   - [ ] Event: `support.billing.lookup`

3. **Technical Auto-Response (Sentry Read-Only)**
   - [ ] Create: `app/api/support/technical/route.ts`
   - [ ] Sentry client in read-only mode: `SENTRY_DSN_RO`
   - [ ] Surface recent issue IDs + error patterns
   - [ ] Self-help guidance: "We've seen this before. Try: [steps]"
   - [ ] **Guardrail:** Never modify issues; read-only access only
   - [ ] Event: `support.technical.lookup`

4. **Chatbot Support Widget**
   - [ ] Create chat UI component: `components/SupportChat.tsx`
   - [ ] Embed in main layout (floating button, bottom-right)
   - [ ] Three intents: FAQ → Billing → Technical → Escalate if <70% confident
   - [ ] Analytics: track deflection % (target ≥70%)
   - [ ] PII redaction: never log customer PII from lookups

**Backend (Days 16-18: Core AI)**

- [ ] Claude Haiku integration: `POST /api/ai/business-description`
- [ ] Dispute analysis: `POST /api/ai/analyze-dispute`
- [ ] Rate limiting (A$20/month budget for core + support)
- [ ] E2E testing (critical paths)

**Frontend (Days 16-18):**

- [ ] AI description generation trigger
- [ ] Dispute analysis display in admin panel
- [ ] Support chat widget (FAQ, Billing, Technical flows)
- [ ] Form validation improvements
- [ ] Accessibility audit (lighthouse score 90+)

**Testing (Days 16-18: Support Flows)**

- [ ] **Billing lookup test:** Given known customer email → bot returns last 3 invoice IDs; no refund action exposed
- [ ] **Sentry lookup test:** Given error keyword → bot returns recent issue ID + self-help steps
- [ ] **Deflection metric:** Simulate 20 FAQ tickets → ≥14 resolved without escalation
- [ ] **PII redaction:** Verify no customer names/emails logged in transcripts

**Days 19-20 (Joint):**

- [ ] Deploy to Vercel + Supabase production
- [ ] Smoke testing in production (including support chat)
- [ ] Performance optimization (Lighthouse)
- [ ] Support ops ready: FAQ index stable, Stripe/Sentry read-only tokens active
- [ ] Go-live December 1 ✅

---

## Daily Standups (Template)

**Time:** 10am, 15 mins  
**Format:**

1. **Backend:** What I shipped yesterday, what I'm doing today, blockers
2. **Frontend:** What I shipped yesterday, what I'm doing today, blockers
3. **Decisions:** Any code reviews, scope questions, escalations?

**Example Day 3 Standup:**

- **Backend:** "Shipped RLS policies + first API route. Today: data validation + Supabase client. No blockers."
- **Frontend:** "Copied UI components + set up layouts. Today: Create page structure. Waiting on API contract."
- **Decisions:** "API contract: POST /api/business returns { id, name, suburb, ... }. Frontend good to proceed."

---

## Deployment Checklist (Day 19-20)

- [ ] Vercel project created + GitHub connected
- [ ] Environment variables set: `NEXT_PUBLIC_SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY`, `STRIPE_SECRET_KEY`
- [ ] Supabase production DB created + migrations applied
- [ ] Stripe production keys set
- [ ] Authentication tested (login flow end-to-end)
- [ ] Payment flow tested (test card: 4242 4242 4242 4242)
- [ ] Refund flow tested (approve/reject)
- [ ] Dispute workflow tested (admin resolution)
- [ ] All routes responding 200 OK
- [ ] Lighthouse score 90+ (performance)
- [ ] SSL certificate active
- [ ] Domain configured (if applicable)
- [ ] Backup strategy in place
- [ ] Monitoring configured (Sentry for errors)
- [ ] **SUPPORT OPS READY:**
  - [ ] Claude API key configured + rate limit respected
  - [ ] FAQ index populated + searchable
  - [ ] Stripe read-only token provisioned (no write access)
  - [ ] Sentry read-only token provisioned (no issue modification)
  - [ ] Support chat widget embedded + functional
  - [ ] Redaction middleware active (no PII in logs)
  - [ ] Analytics events firing: `support.chatbot.shown/resolved/escalated`
  - [ ] No SLA/compensation messaging in UI or docs
  - [ ] Legal disclaimer visible: "No SLA in MVP"
- [ ] **FINAL: Deploy to production**

---

## Risk Mitigation

### Risk: Supabase Query Slow

**Mitigation:** Add Redis caching layer (Upstash) if needed week 4

### Risk: Stripe Webhook Failures

**Mitigation:** Test webhook locally day 1, use Stripe CLI: `stripe listen --forward-to localhost:3000/api/webhooks/stripe`

### Risk: Data Migration Issues

**Mitigation:** Validate row counts before go-live, compare MySQL vs PostgreSQL totals

### Risk: Team Blockers

**Mitigation:** Daily standups catch issues early, have contingency scope cuts ready

### Risk: December 1 Slippage

**Mitigation:** Deploy to staging Dec 1, go-live Dec 2 if needed (1-day buffer)

---

## Success Criteria (Go-Live Readiness)

- ✅ All 8 API routes stable (no 5xx errors)
- ✅ Refund workflow end-to-end (request → approval → Stripe refund)
- ✅ Dispute workflow end-to-end (escalation → admin decision → closure)
- ✅ Stripe payments working (test orders created successfully)
- ✅ Claude AI returning business descriptions (rate limit respected)
- ✅ Auth working (signup, login, logout)
- ✅ RLS policies preventing unauthorized access
- ✅ No 4xx/5xx errors in production logs (24-hour monitoring)
- ✅ Lighthouse score 90+
- ✅ 0 CRITICAL security vulnerabilities (npm audit --audit-level=critical)
- ✅ **Support Ops:**
  - ✅ FAQ chatbot returning relevant results (≥70% accuracy)
  - ✅ Billing lookup working (Stripe read-only token secure)
  - ✅ Technical lookup working (Sentry read-only token secure)
  - ✅ Support chat widget embedded + visible
  - ✅ PII redaction active (customer data not persisted)
  - ✅ Deflection rate tracked (target ≥70%)
  - ✅ Founder load <1 hr/week (monitored via dashboards)
  - ✅ No SLA promises in UI, docs, or legal

---

## Post-Launch (Phase 1.5 - Defer to January)

Once you ship on Dec 1, immediately prioritize:

1. **Vendor Tier System** (featured, basic subscription)
2. **Shopping Cart** (multi-vendor orders)
3. **Advanced Search** (filters, sorting)
4. **Remaining 39 AI Automations** (from v1.1 Phase 1)
5. **Admin Analytics Dashboard**

This keeps momentum going while you validate product-market fit with Dec 1 MVP.

---

## Questions?

- **Day X blocker?** Escalate in standup, adjust sprint scope
- **API contract?** Codify in `lib/schemas.ts` first, then implement
- **Code review?** Do async reviews (don't wait for sync meetings)
- **Deployment?** Stage to Vercel Preview first, then production

**You've got this.** 4.5 weeks, 2 developers, reuse 60% of current code.

**December 1 launch is achievable.** ✅
